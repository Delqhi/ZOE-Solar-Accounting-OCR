# Story F1 — Guardrails bei OCR/Parsing

## Beschreibung

Wir härten die Verarbeitung von OCR-Ergebnissen so, dass ungewöhnliche/inkonsistente AI-Ausgaben (Typfehler, alternative Datums-/Zahlenformate, Währungs-Suffixe, partielle Felder) **niemals** zu Crashes führen und die Daten nach klaren Regeln normalisiert werden.

Schwerpunkte:
- **Feld-/Typkonflikte**: Strings/Numbers/Nulls/Arrays in unerwarteter Form werden defensiv behandelt.
- **Datumsformate**: Neben ISO (`YYYY-MM-DD`) sollen gängige Beleg-Datumsformate robust nach ISO normalisiert werden.
- **Zahlenformate**: Deutsche Formate (Komma-Dezimal, Tausenderpunkte), Währungszeichen (`€`), Leerzeichen werden robust geparst.
- **Rundungs-/Summenlogik (Guardrail)**: Wenn Netto/MwSt/Brutto widersprüchlich sind, wird das Ergebnis stabil normalisiert und als „prüfen“ kenntlich gemacht (ohne stilles Überschreiben in eine falsche Zahl).

## Akzeptanzkriterien

- Keine Runtime-Errors bei folgenden Inputklassen:
  - `null` / `undefined` / primitives statt Objekt
  - Zahlenfelder als Strings (inkl. `"1.234,56 €"`, `"1234.56"`, `"1 234,56"`)
  - `lineItems` als `null`, Objekt, leeres Array, Array mit Mixed Types
- Datumsnormalisierung:
  - `belegDatum` akzeptiert zusätzlich mindestens: `DD.MM.YYYY`, `D.M.YYYY`, `DD/MM/YYYY`, `YYYY/MM/DD`, `DD-MM-YYYY`, `DD.MM.YY`.
  - Ergebnis ist immer ISO (`YYYY-MM-DD`).
  - Wenn Datum nicht parsebar: es wird ein stabiler Fallback gesetzt und ein Hinweis erzeugt („Datum unklar – bitte prüfen“).
- Zahlennormalisierung:
  - `nettoBetrag`, `mwstBetrag*`, `bruttoBetrag` enden immer als finite `number`.
  - Tausendertrenner/Währungssymbole werden ignoriert; Dezimalstellen werden korrekt interpretiert.
- Line-Items:
  - `lineItems` wird zu `LineItem[]` normalisiert; Items ohne `description` werden verworfen.
  - `amount` wird nur gesetzt, wenn parsebar; sonst entweder weggelassen oder auf `0` (konsequent nach gewählter Regel, dokumentiert im Code).
- Summen-/Rundungs-Guardrail:
  - Falls `bruttoBetrag` fehlt/0 ist, aber `nettoBetrag` + MwSt vorhanden sind, darf `bruttoBetrag` **nur dann** aus `netto + mwst` abgeleitet werden, wenn die Werte plausibel sind.
  - Falls ein Widerspruch erkannt wird (z.B. `|netto + mwst - brutto| > Toleranz`), wird das Ergebnis **nicht** stillschweigend „glattgezogen“, sondern als „prüfen“ markiert (z.B. via `ocr_rationale` Ergänzung oder separatem Warnhinweis-Feld – je nach Implementationsentscheidung).
- Bestehende Felder/Verhalten bleiben kompatibel:
  - `normalizeExtractedData()` liefert weiterhin ein vollständiges `ExtractedData` Objekt.

## Out of Scope

- Prompt-/Model-Tuning (Gemini/Qwen) über kleinere Anpassungen hinaus
- Neue Views/Seiten
- Vollautomatische „Korrektur“ falscher Beträge ohne Kennzeichnung

## Touchpoints

- services/extractedDataNormalization.ts
- services/geminiService.ts (Eingangs-/Ausgangsnormalisierung)
- services/fallbackService.ts (Eingangs-/Ausgangsnormalisierung)
- types.ts (nur falls Warnhinweis-/Meta-Feld ergänzt wird)

## Test-Hinweise

- Manuell: Upload von Belegen mit Datumsvarianten (z.B. `14.12.2025`, `14/12/2025`) und Beträgen mit `€`/Tausenderpunkten.
- Manuell: Simulierte OCR-Outputs (DevTools) in `normalizeExtractedData()` einspeisen (z.B. `bruttoBetrag: "1.234,56 €"`).
- Regression: `npm run check`.
