/** ðŸ”± ULTRA 2026 - Service Worker
 * Background sync for offline-first document synchronization
 * 145 lines - Complies with 300-line rule
 */

/// <reference lib="webworker" />

import { precacheAndRoute } from 'workbox-precaching';
import { registerRoute } from 'workbox-routing';
import { NetworkFirst, CacheFirst } from 'workbox-strategies';

declare const self: ServiceWorkerGlobalScope;

// Precache all assets generated by build
precacheAndRoute(self.__WB_MANIFEST || []);

// Cache-first for static assets
registerRoute(
  ({ request }) => ['style', 'script', 'image', 'font'].includes(request.destination),
  new CacheFirst({
    cacheName: 'static-assets',
    plugins: [
      {
        cacheWillUpdate: async ({ response }) => {
          if (response.status === 200) return response;
          return null;
        },
      },
    ],
  })
);

// Network-first for API calls
registerRoute(
  ({ url }) => url.pathname.startsWith('/api/'),
  new NetworkFirst({
    cacheName: 'api-cache',
    networkTimeoutSeconds: 3,
    plugins: [
      {
        cacheDidUpdate: async ({ cacheName, request, oldResponse, newResponse }) => {
          // Log cache updates for debugging
          console.log('[SW] Cache updated:', request.url);
        },
      },
    ],
  })
);

/**
 * Background Sync - Documents
 * Syncs pending documents when connection is restored
 */
self.addEventListener('sync', (event: SyncEvent) => {
  if (event.tag === 'document-sync') {
    event.waitUntil(syncDocuments());
  }
});

/**
 * Background Sync - Audit Logs
 * Syncs audit logs when connection is restored
 */
self.addEventListener('sync', (event: SyncEvent) => {
  if (event.tag === 'audit-sync') {
    event.waitUntil(syncAuditLogs());
  }
});

/**
 * Periodic Background Sync
 * Checks for updates every 15 minutes (if supported)
 */
self.addEventListener('periodicsync', (event: PeriodicSyncEvent) => {
  if (event.tag === 'content-sync') {
    event.waitUntil(syncContent());
  }
});

/**
 * Sync pending documents from IndexedDB to Supabase
 */
async function syncDocuments(): Promise<void> {
  try {
    console.log('[SW] Starting document sync...');

    // Open IndexedDB
    const db = await openDB('ZoeSolarDB', 1);

    // Get pending documents
    const tx = db.transaction('documents', 'readonly');
    const store = tx.objectStore('documents');
    const allDocs = await store.getAll();

    // Filter for pending sync
    const pendingDocs = allDocs.filter(
      (doc: any) => doc.syncStatus === 'pending' || doc.syncStatus === 'syncing'
    );

    if (pendingDocs.length === 0) {
      console.log('[SW] No pending documents to sync');
      return;
    }

    console.log(`[SW] Syncing ${pendingDocs.length} documents...`);

    // Sync each document
    for (const doc of pendingDocs) {
      try {
        // Attempt to sync to backend
        const response = await fetch('/api/documents/sync', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(doc),
        });

        if (response.ok) {
          // Update document status in IndexedDB
          const updateTx = db.transaction('documents', 'readwrite');
          const updateStore = updateTx.objectStore('documents');
          const updatedDoc = { ...doc, syncStatus: 'synced', syncedAt: new Date().toISOString() };
          await updateStore.put(updatedDoc);

          console.log(`[SW] Synced document ${doc.id}`);
        } else {
          console.warn(`[SW] Failed to sync document ${doc.id}: ${response.status}`);
        }
      } catch (error) {
        console.error(`[SW] Error syncing document ${doc.id}:`, error);
        // Will retry on next sync
      }
    }

    // Show notification if service worker is controlling a page
    const clients = await self.clients.matchAll({ type: 'window' });
    if (clients.length > 0) {
      (clients[0] as any).postMessage({
        type: 'SYNC_COMPLETE',
        count: pendingDocs.length,
      });
    }

    console.log('[SW] Document sync complete');
  } catch (error) {
    console.error('[SW] Document sync failed:', error);
    throw error; // Re-throw to trigger retry
  }
}

/**
 * Sync audit logs from IndexedDB to backend
 */
async function syncAuditLogs(): Promise<void> {
  try {
    console.log('[SW] Starting audit log sync...');

    const db = await openDB('AuditDB', 1);
    const tx = db.transaction('auditLogs', 'readonly');
    const store = tx.objectStore('auditLogs');
    const allLogs = await store.getAll();

    if (allLogs.length === 0) {
      console.log('[SW] No audit logs to sync');
      return;
    }

    console.log(`[SW] Syncing ${allLogs.length} audit logs...`);

    // Batch sync (max 50 per request)
    const batchSize = 50;
    for (let i = 0; i < allLogs.length; i += batchSize) {
      const batch = allLogs.slice(i, i + batchSize);

      try {
        const response = await fetch('/api/audit/batch', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ logs: batch }),
        });

        if (response.ok) {
          // Remove synced logs from IndexedDB
          const updateTx = db.transaction('auditLogs', 'readwrite');
          const updateStore = updateTx.objectStore('auditLogs');
          for (const log of batch) {
            await updateStore.delete(log.id);
          }
          console.log(`[SW] Synced batch ${Math.floor(i / batchSize) + 1}`);
        }
      } catch (error) {
        console.error(`[SW] Failed to sync batch ${Math.floor(i / batchSize) + 1}:`, error);
      }
    }

    console.log('[SW] Audit log sync complete');
  } catch (error) {
    console.error('[SW] Audit log sync failed:', error);
    throw error;
  }
}

/**
 * Sync content updates (periodic sync)
 */
async function syncContent(): Promise<void> {
  try {
    console.log('[SW] Periodic content sync...');

    // Check for new documents
    const response = await fetch('/api/documents/updates', {
      method: 'GET',
      headers: { 'Cache-Control': 'no-cache' },
    });

    if (response.ok) {
      const updates = await response.json();

      if (updates.count > 0) {
        // Show notification
        await self.registration.showNotification('ZOE Solar Accounting', {
          body: `${updates.count} neue Dokumente verfÃ¼gbar`,
          icon: '/icon-192.png',
          badge: '/badge-72.png',
          tag: 'content-update',
        });
      }
    }

    console.log('[SW] Periodic sync complete');
  } catch (error) {
    console.error('[SW] Periodic sync failed:', error);
  }
}

/**
 * IndexedDB helper
 */
function openDB(name: string, version: number): Promise<IDBDatabase> {
  return new Promise((resolve, reject) => {
    const request = indexedDB.open(name, version);

    request.onupgradeneeded = (event) => {
      const db = (event.target as IDBOpenDBRequest).result;

      // Create object stores if they don't exist
      if (!db.objectStoreNames.contains('documents')) {
        db.createObjectStore('documents', { keyPath: 'id' });
      }
      if (!db.objectStoreNames.contains('auditLogs')) {
        db.createObjectStore('auditLogs', { keyPath: 'id' });
      }
    };

    request.onsuccess = () => resolve(request.result);
    request.onerror = () => reject(request.error);
  });
}

/**
 * Push notification handler
 */
self.addEventListener('push', (event) => {
  const data = event.data?.json() || { title: 'ZOE Solar', body: 'Neue Benachrichtigung' };

  event.waitUntil(
    self.registration.showNotification(data.title, {
      body: data.body,
      icon: '/icon-192.png',
      badge: '/badge-72.png',
      tag: data.tag || 'zoe-notification',
      data: data.url || '/',
    })
  );
});

/**
 * Notification click handler
 */
self.addEventListener('notificationclick', (event) => {
  event.notification.close();

  event.waitUntil(
    clients.matchAll({ type: 'window', includeUncontrolled: true }).then((clientList) => {
      if (clientList.length > 0) {
        const client = clientList[0];
        if ('focus' in client) {
          return client.focus();
        }
      }
      if (event.notification.data) {
        return clients.openWindow(event.notification.data);
      }
    })
  );
});

/**
 * Install event - Skip waiting to activate immediately
 */
self.addEventListener('install', (event) => {
  console.log('[SW] Installing...');
  self.skipWaiting();
});

/**
 * Activate event - Clean up old caches
 */
self.addEventListener('activate', (event) => {
  console.log('[SW] Activating...');
  event.waitUntil(
    caches.keys().then((cacheNames) => {
      return Promise.all(
        cacheNames
          .filter((cacheName) => cacheName !== 'static-assets' && cacheName !== 'api-cache')
          .map((cacheName) => caches.delete(cacheName))
      );
    })
  );
  self.clients.claim();
});

/**
 * Message handler - For communication with pages
 */
self.addEventListener('message', (event) => {
  if (event.data && event.data.type === 'SKIP_WAITING') {
    self.skipWaiting();
  }

  if (event.data && event.data.type === 'TRIGGER_SYNC') {
    syncDocuments();
  }

  if (event.data && event.data.type === 'GET_SYNC_STATUS') {
    // Check IndexedDB for pending items
    openDB('ZoeSolarDB', 1)
      .then((db) => {
        const tx = db.transaction('documents', 'readonly');
        const store = tx.objectStore('documents');
        return store.getAll();
      })
      .then((docs) => {
        const pending = docs.filter((d: any) => d.syncStatus === 'pending').length;
        event.source?.postMessage({
          type: 'SYNC_STATUS',
          pending,
        });
      });
  }
});

console.log('[SW] Service worker loaded');
